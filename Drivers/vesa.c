#include "vesa.h"
#include <stdint.h>

struct framebuffer fb;
static uint8_t current_font_size = 1;
// Multiboot info structure

// Simple 8x8 font - only characters we need
// In vesa.c, replace your font array with this one:
static const uint8_t font[128][8] = {
   [0] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // NULL
    [' '] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // Space
    ['!'] = {0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x00},
    ['"'] = {0x6C,0x6C,0x6C,0x00,0x00,0x00,0x00,0x00},
    ['#'] = {0x6C,0x6C,0xFE,0x6C,0xFE,0x6C,0x6C,0x00},
    ['$'] = {0x18,0x3E,0x60,0x3C,0x06,0x7C,0x18,0x00},
    ['%'] = {0x00,0x63,0x66,0x0C,0x18,0x33,0x63,0x00},
    ['&'] = {0x1C,0x36,0x1C,0x3B,0x6E,0x66,0x3B,0x00},
    ['\''] = {0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00},
    ['('] = {0x0C,0x18,0x30,0x30,0x30,0x18,0x0C,0x00},
    [')'] = {0x30,0x18,0x0C,0x0C,0x0C,0x18,0x30,0x00},
    ['*'] = {0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00},
    ['+'] = {0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00},
    [','] = {0x00,0x00,0x00,0x00,0x18,0x18,0x30,0x00},
    ['-'] = {0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00},
    ['.'] = {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00},
    ['/'] = {0x03,0x06,0x0C,0x18,0x30,0x60,0x40,0x00},
    
    // Numbers
    ['0'] = {0x3C,0x66,0x6E,0x76,0x66,0x66,0x3C,0x00},
    ['1'] = {0x18,0x38,0x18,0x18,0x18,0x18,0x7E,0x00},
    ['2'] = {0x3C,0x66,0x06,0x0C,0x18,0x30,0x7E,0x00},
    ['3'] = {0x3C,0x66,0x06,0x1C,0x06,0x66,0x3C,0x00},
    ['4'] = {0x0C,0x1C,0x3C,0x6C,0x7E,0x0C,0x0C,0x00},
    ['5'] = {0x7E,0x60,0x7C,0x06,0x06,0x66,0x3C,0x00},
    ['6'] = {0x1C,0x30,0x60,0x7C,0x66,0x66,0x3C,0x00},
    ['7'] = {0x7E,0x06,0x0C,0x18,0x30,0x30,0x30,0x00},
    ['8'] = {0x3C,0x66,0x66,0x3C,0x66,0x66,0x3C,0x00},
    ['9'] = {0x3C,0x66,0x66,0x3E,0x06,0x0C,0x38,0x00},
    
    // More symbols
    [':'] = {0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00},
    [';'] = {0x00,0x18,0x18,0x00,0x18,0x18,0x30,0x00},
    ['<'] = {0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x00},
    ['='] = {0x00,0x00,0x7E,0x00,0x7E,0x00,0x00,0x00},
    ['>'] = {0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x00},
    ['?'] = {0x3C,0x66,0x0C,0x18,0x18,0x00,0x18,0x00},
    ['@'] = {0x3C,0x66,0x6E,0x6A,0x6E,0x60,0x3C,0x00},
    
    // Uppercase letters
    ['A'] = {0x18,0x3C,0x66,0x66,0x7E,0x66,0x66,0x00},
    ['B'] = {0x7C,0x66,0x66,0x7C,0x66,0x66,0x7C,0x00},
    ['C'] = {0x3C,0x66,0x60,0x60,0x60,0x66,0x3C,0x00},
    ['D'] = {0x78,0x6C,0x66,0x66,0x66,0x6C,0x78,0x00},
    ['E'] = {0x7E,0x60,0x60,0x78,0x60,0x60,0x7E,0x00},
    ['F'] = {0x7E,0x60,0x60,0x78,0x60,0x60,0x60,0x00},
    ['G'] = {0x3C,0x66,0x60,0x6E,0x66,0x66,0x3C,0x00},
    ['H'] = {0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x00},
    ['I'] = {0x7E,0x18,0x18,0x18,0x18,0x18,0x7E,0x00},
    ['J'] = {0x3E,0x0C,0x0C,0x0C,0x0C,0x6C,0x38,0x00},
    ['K'] = {0x66,0x6C,0x78,0x70,0x78,0x6C,0x66,0x00},
    ['L'] = {0x60,0x60,0x60,0x60,0x60,0x60,0x7E,0x00},
    ['M'] = {0x63,0x77,0x7F,0x6B,0x63,0x63,0x63,0x00},
    ['N'] = {0x66,0x76,0x7E,0x7E,0x6E,0x66,0x66,0x00},
    ['O'] = {0x3C,0x66,0x66,0x66,0x66,0x66,0x3C,0x00},
    ['P'] = {0x7C,0x66,0x66,0x7C,0x60,0x60,0x60,0x00},
    ['Q'] = {0x3C,0x66,0x66,0x66,0x6A,0x6C,0x36,0x00},
    ['R'] = {0x7C,0x66,0x66,0x7C,0x78,0x6C,0x66,0x00},
    ['S'] = {0x3C,0x66,0x60,0x3C,0x06,0x66,0x3C,0x00},
    ['T'] = {0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x00},
    ['U'] = {0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00},
    ['V'] = {0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00},
    ['W'] = {0x63,0x63,0x63,0x6B,0x7F,0x77,0x63,0x00},
    ['X'] = {0x66,0x66,0x3C,0x18,0x3C,0x66,0x66,0x00},
    ['Y'] = {0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x00},
    ['Z'] = {0x7E,0x06,0x0C,0x18,0x30,0x60,0x7E,0x00},
    
    // Lowercase letters
    ['a'] = {0x00,0x00,0x3C,0x06,0x3E,0x66,0x3E,0x00},
    ['b'] = {0x60,0x60,0x7C,0x66,0x66,0x66,0x7C,0x00},
    ['c'] = {0x00,0x00,0x3C,0x66,0x60,0x66,0x3C,0x00},
    ['d'] = {0x06,0x06,0x3E,0x66,0x66,0x66,0x3E,0x00},
    ['e'] = {0x00,0x00,0x3C,0x66,0x7E,0x60,0x3C,0x00},
    ['f'] = {0x1C,0x30,0x7C,0x30,0x30,0x30,0x30,0x00},
    ['g'] = {0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x3C},
    ['h'] = {0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x00},
    ['i'] = {0x18,0x00,0x18,0x18,0x18,0x18,0x0C,0x00},
    ['j'] = {0x0C,0x00,0x0C,0x0C,0x0C,0x0C,0x6C,0x38},
    ['k'] = {0x60,0x60,0x66,0x6C,0x78,0x6C,0x66,0x00},
    ['l'] = {0x18,0x18,0x18,0x18,0x18,0x18,0x0C,0x00},
    ['m'] = {0x00,0x00,0x76,0x7F,0x6B,0x63,0x63,0x00},
    ['n'] = {0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x00},
    ['o'] = {0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x00},
    ['p'] = {0x00,0x00,0x7C,0x66,0x66,0x7C,0x60,0x60},
    ['q'] = {0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x06},
    ['r'] = {0x00,0x00,0x7C,0x66,0x60,0x60,0x60,0x00},
    ['s'] = {0x00,0x00,0x3E,0x60,0x3C,0x06,0x7C,0x00},
    ['t'] = {0x30,0x30,0x7C,0x30,0x30,0x30,0x1C,0x00},
    ['u'] = {0x00,0x00,0x66,0x66,0x66,0x66,0x3E,0x00},
    ['v'] = {0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x00},
    ['w'] = {0x00,0x00,0x63,0x6B,0x7F,0x77,0x63,0x00},
    ['x'] = {0x00,0x00,0x66,0x3C,0x18,0x3C,0x66,0x00},
    ['y'] = {0x00,0x00,0x66,0x66,0x66,0x3E,0x06,0x3C},
    ['z'] = {0x00,0x00,0x7E,0x0C,0x18,0x30,0x7E,0x00},
    
    // More symbols
    ['['] = {0x1C,0x30,0x30,0x30,0x30,0x30,0x1C,0x00},
    ['\\'] = {0x40,0x60,0x30,0x18,0x0C,0x06,0x02,0x00},
    [']'] = {0x38,0x0C,0x0C,0x0C,0x0C,0x0C,0x38,0x00},
    ['^'] = {0x18,0x3C,0x66,0x00,0x00,0x00,0x00,0x00},
    ['_'] = {0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00},
    ['`'] = {0x30,0x18,0x0C,0x00,0x00,0x00,0x00,0x00},
    
    // Additional brackets
    ['{'] = {0x0E,0x18,0x18,0x70,0x18,0x18,0x0E,0x00},
    ['|'] = {0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00},
    ['}'] = {0x70,0x18,0x18,0x0E,0x18,0x18,0x70,0x00},
    ['~'] = {0x00,0x00,0x3B,0x6E,0x00,0x00,0x00,0x00}
};
struct multiboot_info {
    uint32_t flags;
    uint32_t mem_lower;
    uint32_t mem_upper;
    uint32_t boot_device;
    uint32_t cmdline;
    uint32_t mods_count;
    uint32_t mods_addr;
    uint32_t syms[4];
    uint32_t mmap_length;
    uint32_t mmap_addr;
    uint32_t drives_length;
    uint32_t drives_addr;
    uint32_t config_table;
    uint32_t boot_loader_name;
    uint32_t apm_table;
    uint32_t vbe_control_info;
    uint32_t vbe_mode_info;
    uint16_t vbe_mode;
    uint16_t vbe_interface_seg;
    uint16_t vbe_interface_off;
    uint16_t vbe_interface_len;
    // These are the crucial fields for graphics mode
    uint64_t framebuffer_addr;
    uint32_t framebuffer_pitch;
    uint32_t framebuffer_width;
    uint32_t framebuffer_height;
    uint8_t framebuffer_bpp;
    uint8_t framebuffer_type;
} __attribute__((packed));
void write_string1(int color, const char* str) {
    volatile char* video_memory = (volatile char*)0xB8000;
    while(*str) {
        *video_memory = *str;
        video_memory++;
        *video_memory = color;
        video_memory++;
        str++;
    }
}

uint8_t get_font_size(void) {
    return current_font_size;
}

uint32_t get_char_width(void) {
    return 8 * current_font_size;
}

uint32_t get_char_height(void) {
    return 8 * current_font_size;
}
void set_pixel(uint32_t x, uint32_t y, uint32_t color) {
    if (x >= fb.width || y >= fb.height) return;
    if (!fb.address) return;
    
    uint32_t *pixel = (uint32_t*)(fb.address + (y * fb.pitch) + (x * 4));
    *pixel = color;
}

void fill_screen(uint32_t color) {
    if (!fb.address) return;
    
    uint32_t total_pixels = fb.width * fb.height;
    uint32_t *pixel = (uint32_t*)fb.address;
    
    for (uint32_t i = 0; i < total_pixels; i++) {
        pixel[i] = color;
    }
}
// Add this function to vesa.c
uint32_t interpolate_color(uint32_t color1, uint32_t color2, uint32_t step, uint32_t total_steps) {
    if (total_steps == 0) return color1;
    
    float ratio = (float)step / total_steps;
    
    uint8_t r1 = (color1 >> 16) & 0xFF;
    uint8_t g1 = (color1 >> 8) & 0xFF;
    uint8_t b1 = color1 & 0xFF;
    
    uint8_t r2 = (color2 >> 16) & 0xFF;
    uint8_t g2 = (color2 >> 8) & 0xFF;
    uint8_t b2 = color2 & 0xFF;
    
    uint8_t r = r1 + (r2 - r1) * ratio;
    uint8_t g = g1 + (g2 - g1) * ratio;
    uint8_t b = b1 + (b2 - b1) * ratio;
    
    return (0xFF << 24) | (r << 16) | (g << 8) | b;
}

void draw_rect(uint32_t x, uint32_t y, uint32_t width, uint32_t height, uint32_t color) {
    // Draw rectangle outline
    for (uint32_t i = 0; i < width; i++) {
        set_pixel(x + i, y, color);
        set_pixel(x + i, y + height - 1, color);
    }
    for (uint32_t i = 0; i < height; i++) {
        set_pixel(x, y + i, color);
        set_pixel(x + width - 1, y + i, color);
    }
}
void init_vesa(uint32_t magic, uint32_t mb_info_ptr) {
    struct multiboot_info *mbi = (struct multiboot_info *)mb_info_ptr;

    if (mbi->flags & (1 << 12)) {
        fb.width = mbi->framebuffer_width;
        fb.height = mbi->framebuffer_height;
        fb.bpp = mbi->framebuffer_bpp;
        fb.pitch = mbi->framebuffer_pitch;
        fb.address = (uint8_t *)(uintptr_t)mbi->framebuffer_addr;
    } else {
        fb.address = 0;
        return;
    }
}

void draw_char(uint32_t x, uint32_t y, char c, uint32_t color) {
    draw_char_scaled(x, y, c, color, current_font_size);
}

void draw_char_scaled(uint32_t x, uint32_t y, char c, uint32_t color, uint8_t scale) {
    if (!fb.address) return;
    unsigned char uc = c;
    if (uc > 127) return;
    
    for (uint32_t cy = 0; cy < 8; cy++) {
        for (uint32_t cx = 0; cx < 8; cx++) {
            if (font[uc][cy] & (1 << (7 - cx))) {
                // Draw scaled pixel
                for (uint32_t sy = 0; sy < scale; sy++) {
                    for (uint32_t sx = 0; sx < scale; sx++) {
                        set_pixel(x + (cx * scale) + sx, y + (cy * scale) + sy, color);
                    }
                }
            }
        }
    }
}

void draw_string(uint32_t x, uint32_t y, const char* str, uint32_t color) {
    draw_string_scaled(x, y, str, color, current_font_size);
}
void fill_rect(uint32_t x, uint32_t y, uint32_t width, uint32_t height, uint32_t color) {
    if (!fb.address) return;
    
    for (uint32_t dy = 0; dy < height; dy++) {
        for (uint32_t dx = 0; dx < width; dx++) {
            set_pixel(x + dx, y + dy, color);
        }
    }
}
void draw_string_scaled(uint32_t x, uint32_t y, const char* str, uint32_t color, uint8_t scale) {
    if (!fb.address) return;
    
    uint32_t start_x = x;
    uint32_t cx = x;
    uint32_t cy = y;
    uint32_t char_width = 8 * scale;
    uint32_t char_height = 8 * scale;
    
    while (*str) {
        if (cx + char_width >= fb.width) {
            cy += char_height;
            cx = start_x;
        }

        if (cy + char_height >= fb.height) {
            return;
        }

        draw_char_scaled(cx, cy, *str, color, scale);
        cx += char_width;
        str++;
    }
}